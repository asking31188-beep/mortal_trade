
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Mortal Trade — Dashboard & Trading Screens (Advanced)</title>

<!-- Libraries -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://s3.tradingview.com/tv.js"></script>

<style>
  :root{
    --bg:#0f1113; --panel:#141617; --muted:#9aa0a6; --accent:#00ffcc;
    --bull:#2e7d32; --bear:#c62828; --neutral:#f9a825;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);color:#e8eef1}
  header{background:#0c0d0e;padding:12px 16px;border-bottom:1px solid #1f2123;position:sticky;top:0;z-index:50}
  .nav{max-width:1200px;margin:0 auto;display:flex;align-items:center;justify-content:space-between}
  .brand{color:var(--accent);font-weight:700}
  .tabs{display:flex;gap:12px}
  .tab-btn{background:transparent;border:1px solid transparent;padding:8px 10px;border-radius:8px;color:inherit;cursor:pointer}
  .tab-btn.active{border-color:#222;color:var(--accent);background:#0e1412}
  .container{max-width:1200px;margin:18px auto;padding:0 14px}
  .controls{display:flex;gap:8px;align-items:center;margin-bottom:12px;flex-wrap:wrap}
  .btn{background:var(--accent);color:#000;border:none;padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:700}
  .small{background:#1a1b1c;color:var(--muted);padding:6px 8px;border-radius:8px}
  h2{color:var(--accent);margin:14px 0}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .card{background:var(--panel);padding:10px;border-radius:10px;border:1px solid #1f2123}
  /* prices */
  #prices{display:flex;gap:12px;flex-wrap:wrap}
  .price-card{min-width:120px;padding:10px;border-radius:8px;background:#0e1112;border:1px solid #1f2325}
  .price-symbol{font-weight:700}
  /* chart */
  .chart-box{background:var(--panel);padding:10px;border-radius:12px;border:1px solid #1f2123}
  canvas{width:100%!important;height:360px!important}
  /* table */
  table{width:100%;border-collapse:collapse;margin-top:10px}
  th,td{padding:8px;border-bottom:1px solid #1b1c1d;text-align:center}
  .green{background:var(--bull);color:#eaffee}
  .red{background:var(--bear);color:#fff0f0}
  .yellow{background:var(--neutral);color:#222}
  /* trading screens */
  .coin-block{background:var(--panel);padding:14px;border-radius:12px;margin-bottom:14px;border:1px solid #1f2123}
  .coin-head{display:flex;justify-content:space-between;align-items:center;gap:12px}
  .card-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:10px;margin-top:10px}
  @media(min-width:900px){.card-grid{grid-template-columns:repeat(5,1fr)}}
  .screen-card{background:#0e1112;padding:10px;border-radius:10px;border:1px solid #222;min-height:100px;display:flex;flex-direction:column;justify-content:space-between}
  .badge{padding:6px 10px;border-radius:999px;font-weight:700;color:#fff}
  .badge.bull{background:var(--bull)}
  .badge.bear{background:var(--bear)}
  .badge.neutral{background:var(--neutral);color:#000}
  .spark{height:36px;width:100%;display:block;margin-top:6px}
  .footer{color:var(--muted);margin-top:18px;text-align:center}
  a { color: var(--accent); text-decoration: none; }
</style>
</head>
<body>
<header>
  <div class="nav">
    <div class="brand">Mortal Trade</div>
    <div class="tabs">
      <button id="btnDash" class="tab-btn active">Dashboard</button>
      <button id="btnScreens" class="tab-btn">Trading Screens</button>
    </div>
  </div>
</header>

<div class="container" id="dashboardView">
  <div class="controls">
    <div class="card">Refresh interval: <strong>5 min</strong></div>
    <button id="refreshNow" class="btn">Refresh now</button>
    <div class="small" id="lastUpdated">Last updated: —</div>
  </div>

  <h2>Live Prices</h2>
  <div id="prices" class="row"></div>

  <h2>Bitcoin — 30 day chart</h2>
  <div class="chart-box card"><canvas id="btcChart"></canvas></div>

  <h2>Latest Crypto News</h2>
  <div id="news" class="card" style="margin-top:8px;padding:12px">Loading news…</div>

  <h2>Performance Table</h2>
  <div id="highBanner" class="card" style="margin-bottom:8px">Loading high-performance strategies…</div>
  <div class="card">
    <table id="perfTable">
      <thead>
        <tr><th>Coin</th><th>Strategy</th><th>Profit %</th><th>Accuracy %</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<div class="container" id="screensView" style="display:none">
  <div class="controls">
    <label class="card">Timeframe:
      <select id="tfSelect">
        <option value="30d" selected>30d (advanced backtest)</option>
      </select>
    </label>
    <label class="card">Filter:
      <select id="filterSelect">
        <option value="all">All</option>
        <option value="bull">Bullish</option>
        <option value="bear">Bearish</option>
        <option value="neutral">Neutral</option>
      </select>
    </label>
    <div class="small">Signals are computed from CoinGecko OHLC (30 days) • Trades simulated with hold=3 candles</div>
  </div>

  <div id="screensContainer"></div>
</div>

<div class="footer">Built with CoinGecko & TradingView • Use responsibly — this is for informational/demo purposes only.</div>

<script>
/* ============================
   Configuration & Utilities
   ============================ */
const COINS = [
  { id: "bitcoin", symbol: "BTC", tv: "BINANCE:BTCUSDT" },
  { id: "ethereum", symbol: "ETH", tv: "BINANCE:ETHUSDT" },
  { id: "dogecoin", symbol: "DOGE", tv: "BINANCE:DOGEUSDT" },
  { id: "binancecoin", symbol: "BNB", tv: "BINANCE:BNBUSDT" },
  { id: "solana", symbol: "SOL", tv: "BINANCE:SOLUSDT" },
];

const HOLD_DAYS = 3;           // backtest holding period for each trade
const REFRESH_MS = 5 * 60 * 1000;
const $ = s => document.querySelector(s);
const $$ = s => Array.from(document.querySelectorAll(s));

function nowStr(){ const d=new Date(); return d.toLocaleString(); }

/* ============================
   Technical helpers (advanced)
   - SMA for MA crossover
   - EMA for MACD
   - RSI (Wilder)
   ============================ */
function sma(arr, period){
  const out = [];
  for (let i=0;i<arr.length;i++){
    if (i+1 < period) { out.push(null); continue; }
    let sum = 0;
    for (let j=i+1-period;j<=i;j++) sum += arr[j];
    out.push(sum/period);
  }
  return out;
}

function ema(arr, period){
  const out = [];
  const k = 2/(period+1);
  let prev = arr[0];
  out.push(prev);
  for (let i=1;i<arr.length;i++){
    prev = arr[i]*k + prev*(1-k);
    out.push(prev);
  }
  return out;
}

// RSI - Wilder's smoothing
function rsi(arr, period=14){
  if (arr.length < period+1) return Array(arr.length).fill(null);
  let gains = 0, losses = 0;
  for (let i=1;i<=period;i++){
    const d = arr[i] - arr[i-1];
    if (d>0) gains += d; else losses -= d;
  }
  gains /= period; losses /= period;
  const out = Array(period).fill(null);
  out.push(100 - (100 / (1 + (gains / (losses || 1e-9)))));
  for (let i=period+1;i<arr.length;i++){
    const d = arr[i] - arr[i-1];
    const gain = d>0?d:0, loss = d<0?-d:0;
    gains = (gains*(period-1) + gain)/period;
    losses = (losses*(period-1) + loss)/period || 1e-9;
    out.push(100 - (100 / (1 + (gains / losses))));
  }
  return out;
}

/* MACD: returns {macdLine, signalLine, hist} arrays */
function macd(arr, fast=12, slow=26, signal=9){
  const emaFast = ema(arr, fast);
  const emaSlow = ema(arr, slow);
  const macdLine = emaFast.map((v,i)=> v - (emaSlow[i] || v));
  const signalLine = ema(macdLine, signal);
  const hist = macdLine.map((v,i)=> v - (signalLine[i] || 0));
  return { macdLine, signalLine, hist };
}

/* ============================
   CoinGecko: fetch OHLC (30-day)
   endpoint: /coins/{id}/ohlc?vs_currency=usd&days=30
   returns [ [ts, open, high, low, close], ... ]
   ============================ */
async function fetchOHLC(coinId, days=30){
  const url = `https://api.coingecko.com/api/v3/coins/${coinId}/ohlc?vs_currency=usd&days=${days}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error(`CoinGecko OHLC failed for ${coinId}: ${res.status}`);
  const json = await res.json();
  // Map to arrays
  const opens = json.map(d => d[1]);
  const highs = json.map(d => d[2]);
  const lows  = json.map(d => d[3]);
  const closes= json.map(d => d[4]);
  const times = json.map(d => d[0]);
  return { opens, highs, lows, closes, times };
}

/* ============================
   Strategy signal for index i (requires enough historic data)
   Each signal function returns "bull" | "bear" | "neutral"
   and also used in backtest
   ============================ */
function signal_MA9_20(closes, i){
  // SMA-based MA crossover at index i (uses data up to i)
  if (i < 19) return "neutral";
  const sma9 = sma(closes.slice(0,i+1), 9).at(-1);
  const sma20= sma(closes.slice(0,i+1),20).at(-1);
  return (sma9 > sma20) ? "bull" : "bear";
}

function signal_RSI14(closes, i){
  if (i < 14) return "neutral";
  const r = rsi(closes.slice(0,i+1),14).at(-1);
  if (r === null) return "neutral";
  if (r > 70) return "bear";
  if (r < 30) return "bull";
  return "neutral";
}

function signal_MACD(closes, i){
  if (i < 26) return "neutral";
  const { macdLine, signalLine } = macd(closes.slice(0,i+1));
  const m = macdLine.at(-1), s = signalLine.at(-1);
  return (m > s) ? "bull":"bear";
}

function signal_Breakout(highs, closes, i){
  // breakout: close(i) > max of previous 7 highs (exclude current)
  if (i < 7) return "neutral";
  const prev7High = Math.max(...highs.slice(i-7, i));
  return closes[i] > prev7High ? "bull" : "neutral";
}

function signal_RSI_OBOS(closes, i){
  if (i < 14) return "neutral";
  const r = rsi(closes.slice(0,i+1),14).at(-1);
  if (r > 70) return "bear";
  if (r < 30) return "bull";
  return "neutral";
}

/* ============================
   Simple backtest engine
   - For each strategy we check every index i where we have enough history
   - When a buy (bull) signal at index i, we enter at close[i+1] and exit at close[i+1+HOLD_DAYS]
   - Returns collected, profit% = avg(return*100), accuracy = % positive trades
   - NOTE: this is a simplified simulation for demonstration/backtest estimation only.
   ============================ */
function backtestStrategy(strategyFn, ohlc){
  const closes = ohlc.closes;
  const highs = ohlc.highs;
  const returns = [];
  for (let i=0; i < closes.length - (HOLD_DAYS + 1); i++){
    // compute signal at index i (based only on data up to i)
    const sig = strategyFn(closes, i, highs);
    if (sig === "bull"){ // only long signals
      const entryIdx = i+1;
      const exitIdx = Math.min(entryIdx + HOLD_DAYS, closes.length - 1);
      const entry = closes[entryIdx];
      const exit  = closes[exitIdx];
      const ret = (exit - entry)/entry * 100;
      returns.push(ret);
    }
  }
  if (returns.length === 0) return { profit: 0, accuracy: 0, trades: 0 };

  const avg = returns.reduce((s,v)=>s+v,0)/returns.length;
  const wins = returns.filter(r=>r>0).length;
  const accuracy = (wins / returns.length) * 100;
  return { profit: Number(avg.toFixed(2)), accuracy: Number(accuracy.toFixed(2)), trades: returns.length };
}

/* ============================
   Compose per-coin performance data
   ============================ */
async function analyzeCoin(coin){
  try {
    const ohlc = await fetchOHLC(coin.id, 30);
    const closes = ohlc.closes, highs = ohlc.highs;

    // Signals for UI (current/latest index)
    const lastIdx = closes.length - 1;
    const signals = {
      ma: signal_MA9_20(closes, lastIdx),
      rsi: signal_RSI14(closes, lastIdx),
      macd: signal_MACD(closes, lastIdx),
      breakout: signal_Breakout(highs, closes, lastIdx),
      rsi_obs: signal_RSI_OBOS(closes, lastIdx)
    };

    // Backtest each strategy
    const perf = [];
    // MA 9/20
    const maPerf = backtestStrategy((c,i)=> signal_MA9_20(c,i), ohlc);
    perf.push({ coin: coin.symbol, strategy: "MA 9/20", profit: maPerf.profit, accuracy: maPerf.accuracy, trades: maPerf.trades });

    // RSI (14) - treat bullish when RSI < 30 (oversold)
    const rsiPerf = backtestStrategy((c,i)=> signal_RSI14(c,i), ohlc);
    perf.push({ coin: coin.symbol, strategy: "RSI 14", profit: rsiPerf.profit, accuracy: rsiPerf.accuracy, trades: rsiPerf.trades });

    // MACD
    const macdPerf = backtestStrategy((c,i)=> signal_MACD(c,i), ohlc);
    perf.push({ coin: coin.symbol, strategy: "MACD", profit: macdPerf.profit, accuracy: macdPerf.accuracy, trades: macdPerf.trades });

    // Breakout
    const breakoutPerf = backtestStrategy((c,i, highsArg)=> signal_Breakout(highsArg || [], c, i), ohlc);
    perf.push({ coin: coin.symbol, strategy: "Breakout", profit: breakoutPerf.profit, accuracy: breakoutPerf.accuracy, trades: breakoutPerf.trades });

    // RSI OB/OS (explicit)
    const roPerf = backtestStrategy((c,i)=> signal_RSI_OBOS(c,i), ohlc);
    perf.push({ coin: coin.symbol, strategy: "RSI OB/OS", profit: roPerf.profit, accuracy: roPerf.accuracy, trades: roPerf.trades });

    return { coin: coin.symbol, signals, perf, ohlc };
  } catch (e){
    console.warn("analyzeCoin error", coin, e);
    return { coin: coin.symbol, error: true, perf: [] };
  }
}

/* ============================
   UI helpers: badges, sparklines
   ============================ */
function badgeHTML(type){
  const cls = type==="bull" ? "badge bull" : type==="bear" ? "badge bear" : "badge neutral";
  const text = type==="bull" ? "Bullish" : type==="bear" ? "Bearish" : "Neutral";
  return `<span class="${cls}">${text}</span>`;
}

function sparklineSVG(values){
  if (!values || values.length < 2) return '';
  const w=240, h=36, pad=2;
  const min=Math.min(...values), max=Math.max(...values);
  const range = max - min || 1e-6;
  const xs = values.map((_,i)=> pad + (i*(w-2*pad))/(values.length-1));
  const ys = values.map(v => h - pad - ((v-min)*(h-2*pad))/range);
  const path = xs.map((x,i)=> (i? 'L':'M') + x.toFixed(1) + ',' + ys[i].toFixed(1)).join(' ');
  return `<svg class="spark" viewBox="0 0 ${w} ${h}" preserveAspectRatio="none"><path d="${path}" fill="none" stroke="${'#00ffcc'}" stroke-width="2" /></svg>`;
}

/* ============================
   Rendering functions
   ============================ */
async function refreshAll(){
  try{
    $("#refreshNow").disabled = true;
    $("#lastUpdated").textContent = `Refreshing…`;
    // 1) Live prices (simple)
    await renderPrices();

    // 2) Dashboard BTC chart
    await renderBtcChart();

    // 3) News
    await renderNews();

    // 4) Analyze each coin (indicators + backtests) in parallel
    const analyses = await Promise.all(COINS.map(c => analyzeCoin(c)));

    // Build performance table and high-performance banner
    renderPerformanceTable(analyses);

    // Build trading screens area (signals + charts)
    renderTradingScreens(analyses);

    $("#lastUpdated").textContent = `Last updated: ${nowStr()}`;
  } catch(e){
    console.error(e);
    $("#lastUpdated").textContent = `Error: ${e.message}`;
  } finally {
    $("#refreshNow").disabled = false;
  }
}

async function renderPrices(){
  try{
    const ids = COINS.map(c=>c.id).join(',');
    const res = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${ids}&vs_currencies=usd&include_24hr_change=true`);
    const json = await res.json();
    const container = $("#prices");
    container.innerHTML = '';
    COINS.forEach(c => {
      const d = json[c.id];
      if (!d) return;
      const pct = Number(d.usd_24h_change).toFixed(2);
      const p = Number(d.usd).toLocaleString(undefined, {minimumFractionDigits:2, maximumFractionDigits:2});
      const el = document.createElement('div');
      el.className = 'price-card card';
      el.innerHTML = `<div class="price-symbol">${c.symbol}</div><div>$${p}</div><div style="color:${pct>=0? 'lightgreen':'salmon'}">${pct}% (24h)</div>`;
      container.appendChild(el);
    });
  } catch (e){
    console.warn("renderPrices err", e);
    $("#prices").innerHTML = '<div class="card">Failed to load prices</div>';
  }
}

let btcChartInstance = null;
async function renderBtcChart(){
  try{
    const res = await fetch('https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=30');
    const json = await res.json();
    const labels = json.prices.map(p => new Date(p[0]).toLocaleDateString());
    const data = json.prices.map(p => p[1]);
    const ctx = document.getElementById('btcChart').getContext('2d');
    if (btcChartInstance) { btcChartInstance.data.labels = labels; btcChartInstance.data.datasets[0].data = data; btcChartInstance.update(); return; }
    btcChartInstance = new Chart(ctx, {
      type: 'line',
      data: { labels, datasets: [{ label: 'BTC USD', data, borderColor: '#00ffcc', backgroundColor: 'rgba(0,255,204,0.05)' }]},
      options: { responsive:true, plugins:{legend:{display:false}}, scales:{x:{ticks:{color:'#cfd6d9'}}, y:{ticks:{color:'#cfd6d9'}}} }
    });
  } catch(e){
    console.warn("btc chart err", e);
  }
}

async function renderNews(){
  try{
    // Use a free feed proxy (rss2json) to simplify - cryptonews feed used earlier
    const res = await fetch('https://api.rss2json.com/v1/api.json?rss_url=https://cryptonews.com/news/feed');
    const json = await res.json();
    const items = json.items?.slice(0,5) || [];
    $("#news").innerHTML = items.map(it => `<div style="margin-bottom:8px"><a href="${it.link}" target="_blank" rel="noopener noreferrer">${it.title}</a><div style="color:var(--muted);font-size:12px">${it.pubDate}</div></div>`).join('');
  } catch(e){
    console.warn("news err", e);
    $("#news").innerHTML = '<div>Failed to load news.</div>';
  }
}

function renderPerformanceTable(analyses){
  const tbody = $("#perfTable tbody");
  let rows = '';
  let highList = [];
  analyses.forEach(a => {
    if (a.error) return;
    a.perf.forEach(p => {
      const cls = (p.profit > 25 && p.accuracy > 75) ? 'green' : (p.profit < 0 || p.accuracy < 50) ? 'red' : 'yellow';
      rows += `<tr class="${cls}"><td>${p.coin}</td><td>${p.strategy}</td><td>${p.profit}%</td><td>${p.accuracy}%</td></tr>`;
      if (p.profit > 25 && p.accuracy > 75) highList.push(`${p.coin} - ${p.strategy} (${p.profit}%, ${p.accuracy}%, trades:${p.trades})`);
    });
  });
  tbody.innerHTML = rows || '<tr><td colspan="4">No data</td></tr>';
  $("#highBanner").innerHTML = highList.length ? `<strong>High Performance:</strong> ${highList.join(' • ')}` : `<strong>High Performance:</strong> None`;
}

/* Build Trading Screens with signals and TradingView charts */
function renderTradingScreens(analyses){
  const container = $("#screensContainer");
  container.innerHTML = '';
  analyses.forEach(a => {
    const coinInfo = COINS.find(c=>c.symbol === a.coin);
    const section = document.createElement('div');
    section.className = 'coin-block';
    section.innerHTML = `
      <div class="coin-head">
        <div style="font-weight:800">${a.coin} — Trading Screens</div>
        <div style="color:var(--muted)">Trades simulated (hold ${HOLD_DAYS} candles)</div>
      </div>
      <div class="card-grid" id="grid-${a.coin}"></div>
      <div class="chart-box" style="margin-top:12px"><div id="tv-${a.coin}" class="chart"></div></div>
    `;
    container.appendChild(section);

    // If error, show note
    const grid = section.querySelector(`#grid-${a.coin}`);
    if (a.error) {
      grid.innerHTML = `<div class="screen-card">Error fetching data.</div>`;
      return;
    }

    // Signals (latest)
    const signals = a.signals;
    // prepare sparkline from last closes
    const spark = sparklineSVG(a.ohlc.closes.slice(-40));

    const cards = [
      {title: 'MA 9/20 crossover', type: signals.ma, note: signals.ma === 'bull' ? 'MA9 > MA20' : 'MA9 ≤ MA20'},
      {title: 'RSI (14)', type: signals.rsi, note: signals.rsi === 'bull' ? 'RSI < 30 (oversold)' : signals.rsi === 'bear' ? 'RSI > 70' : 'Neutral'},
      {title: 'MACD above signal', type: s
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Mortal Trade — Dashboard & Trading Screens (Advanced)</title>

<!-- Libraries -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://s3.tradingview.com/tv.js"></script>

<style>
  :root{
    --bg:#0f1113; --panel:#141617; --muted:#9aa0a6; --accent:#00ffcc;
    --bull:#2e7d32; --bear:#c62828; --neutral:#f9a825;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);color:#e8eef1}
  header{background:#0c0d0e;padding:12px 16px;border-bottom:1px solid #1f2123;position:sticky;top:0;z-index:50}
  .nav{max-width:1200px;margin:0 auto;display:flex;align-items:center;justify-content:space-between}
  .brand{color:var(--accent);font-weight:700}
  .tabs{display:flex;gap:12px}
  .tab-btn{background:transparent;border:1px solid transparent;padding:8px 10px;border-radius:8px;color:inherit;cursor:pointer}
  .tab-btn.active{border-color:#222;color:var(--accent);background:#0e1412}
  .container{max-width:1200px;margin:18px auto;padding:0 14px}
  .controls{display:flex;gap:8px;align-items:center;margin-bottom:12px;flex-wrap:wrap}
  .btn{background:var(--accent);color:#000;border:none;padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:700}
  .small{background:#1a1b1c;color:var(--muted);padding:6px 8px;border-radius:8px}
  h2{color:var(--accent);margin:14px 0}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .card{background:var(--panel);padding:10px;border-radius:10px;border:1px solid #1f2123}
  /* prices */
  #prices{display:flex;gap:12px;flex-wrap:wrap}
  .price-card{min-width:120px;padding:10px;border-radius:8px;background:#0e1112;border:1px solid #1f2325}
  .price-symbol{font-weight:700}
  /* chart */
  .chart-box{background:var(--panel);padding:10px;border-radius:12px;border:1px solid #1f2123}
  canvas{width:100%!important;height:360px!important}
  /* table */
  table{width:100%;border-collapse:collapse;margin-top:10px}
  th,td{padding:8px;border-bottom:1px solid #1b1c1d;text-align:center}
  .green{background:var(--bull);color:#eaffee}
  .red{background:var(--bear);color:#fff0f0}
  .yellow{background:var(--neutral);color:#222}
  /* trading screens */
  .coin-block{background:var(--panel);padding:14px;border-radius:12px;margin-bottom:14px;border:1px solid #1f2123}
  .coin-head{display:flex;justify-content:space-between;align-items:center;gap:12px}
  .card-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:10px;margin-top:10px}
  @media(min-width:900px){.card-grid{grid-template-columns:repeat(5,1fr)}}
  .screen-card{background:#0e1112;padding:10px;border-radius:10px;border:1px solid #222;min-height:100px;display:flex;flex-direction:column;justify-content:space-between}
  .badge{padding:6px 10px;border-radius:999px;font-weight:700;color:#fff}
  .badge.bull{background:var(--bull)}
  .badge.bear{background:var(--bear)}
  .badge.neutral{background:var(--neutral);color:#000}
  .spark{height:36px;width:100%;display:block;margin-top:6px}
  .footer{color:var(--muted);margin-top:18px;text-align:center}
  a { color: var(--accent); text-decoration: none; }
</style>
</head>
<body>
<header>
  <div class="nav">
    <div class="brand">Mortal Trade</div>
    <div class="tabs">
      <button id="btnDash" class="tab-btn active">Dashboard</button>
      <button id="btnScreens" class="tab-btn">Trading Screens</button>
    </div>
  </div>
</header>

<div class="container" id="dashboardView">
  <div class="controls">
    <div class="card">Refresh interval: <strong>5 min</strong></div>
    <button id="refreshNow" class="btn">Refresh now</button>
    <div class="small" id="lastUpdated">Last updated: —</div>
  </div>

  <h2>Live Prices</h2>
  <div id="prices" class="row"></div>

  <h2>Bitcoin — 30 day chart</h2>
  <div class="chart-box card"><canvas id="btcChart"></canvas></div>

  <h2>Latest Crypto News</h2>
  <div id="news" class="card" style="margin-top:8px;padding:12px">Loading news…</div>

  <h2>Performance Table</h2>
  <div id="highBanner" class="card" style="margin-bottom:8px">Loading high-performance strategies…</div>
  <div class="card">
    <table id="perfTable">
      <thead>
        <tr><th>Coin</th><th>Strategy</th><th>Profit %</th><th>Accuracy %</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<div class="container" id="screensView" style="display:none">
  <div class="controls">
    <label class="card">Timeframe:
      <select id="tfSelect">
        <option value="30d" selected>30d (advanced backtest)</option>
      </select>
    </label>
    <label class="card">Filter:
      <select id="filterSelect">
        <option value="all">All</option>
        <option value="bull">Bullish</option>
        <option value="bear">Bearish</option>
        <option value="neutral">Neutral</option>
      </select>
    </label>
    <div class="small">Signals are computed from CoinGecko OHLC (30 days) • Trades simulated with hold=3 candles</div>
  </div>

  <div id="screensContainer"></div>
</div>

<div class="footer">Built with CoinGecko & TradingView • Use responsibly — this is for informational/demo purposes only.</div>

<script>
/* ============================
   Configuration & Utilities
   ============================ */
const COINS = [
  { id: "bitcoin", symbol: "BTC", tv: "BINANCE:BTCUSDT" },
  { id: "ethereum", symbol: "ETH", tv: "BINANCE:ETHUSDT" },
  { id: "dogecoin", symbol: "DOGE", tv: "BINANCE:DOGEUSDT" },
  { id: "binancecoin", symbol: "BNB", tv: "BINANCE:BNBUSDT" },
  { id: "solana", symbol: "SOL", tv: "BINANCE:SOLUSDT" },
];

const HOLD_DAYS = 3;           // backtest holding period for each trade
const REFRESH_MS = 5 * 60 * 1000;
const $ = s => document.querySelector(s);
const $$ = s => Array.from(document.querySelectorAll(s));

function nowStr(){ const d=new Date(); return d.toLocaleString(); }

/* ============================
   Technical helpers (advanced)
   - SMA for MA crossover
   - EMA for MACD
   - RSI (Wilder)
   ============================ */
function sma(arr, period){
  const out = [];
  for (let i=0;i<arr.length;i++){
    if (i+1 < period) { out.push(null); continue; }
    let sum = 0;
    for (let j=i+1-period;j<=i;j++) sum += arr[j];
    out.push(sum/period);
  }
  return out;
}

function ema(arr, period){
  const out = [];
  const k = 2/(period+1);
  let prev = arr[0];
  out.push(prev);
  for (let i=1;i<arr.length;i++){
    prev = arr[i]*k + prev*(1-k);
    out.push(prev);
  }
  return out;
}

// RSI - Wilder's smoothing
function rsi(arr, period=14){
  if (arr.length < period+1) return Array(arr.length).fill(null);
  let gains = 0, losses = 0;
  for (let i=1;i<=period;i++){
    const d = arr[i] - arr[i-1];
    if (d>0) gains += d; else losses -= d;
  }
  gains /= period; losses /= period;
  const out = Array(period).fill(null);
  out.push(100 - (100 / (1 + (gains / (losses || 1e-9)))));
  for (let i=period+1;i<arr.length;i++){
    const d = arr[i] - arr[i-1];
    const gain = d>0?d:0, loss = d<0?-d:0;
    gains = (gains*(period-1) + gain)/period;
    losses = (losses*(period-1) + loss)/period || 1e-9;
    out.push(100 - (100 / (1 + (gains / losses))));
  }
  return out;
}

/* MACD: returns {macdLine, signalLine, hist} arrays */
function macd(arr, fast=12, slow=26, signal=9){
  const emaFast = ema(arr, fast);
  const emaSlow = ema(arr, slow);
  const macdLine = emaFast.map((v,i)=> v - (emaSlow[i] || v));
  const signalLine = ema(macdLine, signal);
  const hist = macdLine.map((v,i)=> v - (signalLine[i] || 0));
  return { macdLine, signalLine, hist };
}

/* ============================
   CoinGecko: fetch OHLC (30-day)
   endpoint: /coins/{id}/ohlc?vs_currency=usd&days=30
   returns [ [ts, open, high, low, close], ... ]
   ============================ */
async function fetchOHLC(coinId, days=30){
  const url = `https://api.coingecko.com/api/v3/coins/${coinId}/ohlc?vs_currency=usd&days=${days}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error(`CoinGecko OHLC failed for ${coinId}: ${res.status}`);
  const json = await res.json();
  // Map to arrays
  const opens = json.map(d => d[1]);
  const highs = json.map(d => d[2]);
  const lows  = json.map(d => d[3]);
  const closes= json.map(d => d[4]);
  const times = json.map(d => d[0]);
  return { opens, highs, lows, closes, times };
}

/* ============================
   Strategy signal for index i (requires enough historic data)
   Each signal function returns "bull" | "bear" | "neutral"
   and also used in backtest
   ============================ */
function signal_MA9_20(closes, i){
  // SMA-based MA crossover at index i (uses data up to i)
  if (i < 19) return "neutral";
  const sma9 = sma(closes.slice(0,i+1), 9).at(-1);
  const sma20= sma(closes.slice(0,i+1),20).at(-1);
  return (sma9 > sma20) ? "bull" : "bear";
}

function signal_RSI14(closes, i){
  if (i < 14) return "neutral";
  const r = rsi(closes.slice(0,i+1),14).at(-1);
  if (r === null) return "neutral";
  if (r > 70) return "bear";
  if (r < 30) return "bull";
  return "neutral";
}

function signal_MACD(closes, i){
  if (i < 26) return "neutral";
  const { macdLine, signalLine } = macd(closes.slice(0,i+1));
  const m = macdLine.at(-1), s = signalLine.at(-1);
  return (m > s) ? "bull":"bear";
}

function signal_Breakout(highs, closes, i){
  // breakout: close(i) > max of previous 7 highs (exclude current)
  if (i < 7) return "neutral";
  const prev7High = Math.max(...highs.slice(i-7, i));
  return closes[i] > prev7High ? "bull" : "neutral";
}

function signal_RSI_OBOS(closes, i){
  if (i < 14) return "neutral";
  const r = rsi(closes.slice(0,i+1),14).at(-1);
  if (r > 70) return "bear";
  if (r < 30) return "bull";
  return "neutral";
}

/* ============================
   Simple backtest engine
   - For each strategy we check every index i where we have enough history
   - When a buy (bull) signal at index i, we enter at close[i+1] and exit at close[i+1+HOLD_DAYS]
   - Returns collected, profit% = avg(return*100), accuracy = % positive trades
   - NOTE: this is a simplified simulation for demonstration/backtest estimation only.
   ============================ */
function backtestStrategy(strategyFn, ohlc){
  const closes = ohlc.closes;
  const highs = ohlc.highs;
  const returns = [];
  for (let i=0; i < closes.length - (HOLD_DAYS + 1); i++){
    // compute signal at index i (based only on data up to i)
    const sig = strategyFn(closes, i, highs);
    if (sig === "bull"){ // only long signals
      const entryIdx = i+1;
      const exitIdx = Math.min(entryIdx + HOLD_DAYS, closes.length - 1);
      const entry = closes[entryIdx];
      const exit  = closes[exitIdx];
      const ret = (exit - entry)/entry * 100;
      returns.push(ret);
    }
  }
  if (returns.length === 0) return { profit: 0, accuracy: 0, trades: 0 };

  const avg = returns.reduce((s,v)=>s+v,0)/returns.length;
  const wins = returns.filter(r=>r>0).length;
  const accuracy = (wins / returns.length) * 100;
  return { profit: Number(avg.toFixed(2)), accuracy: Number(accuracy.toFixed(2)), trades: returns.length };
}

/* ============================
   Compose per-coin performance data
   ============================ */
async function analyzeCoin(coin){
  try {
    const ohlc = await fetchOHLC(coin.id, 30);
    const closes = ohlc.closes, highs = ohlc.highs;

    // Signals for UI (current/latest index)
    const lastIdx = closes.length - 1;
    const signals = {
      ma: signal_MA9_20(closes, lastIdx),
      rsi: signal_RSI14(closes, lastIdx),
      macd: signal_MACD(closes, lastIdx),
      breakout: signal_Breakout(highs, closes, lastIdx),
      rsi_obs: signal_RSI_OBOS(closes, lastIdx)
    };

    // Backtest each strategy
    const perf = [];
    // MA 9/20
    const maPerf = backtestStrategy((c,i)=> signal_MA9_20(c,i), ohlc);
    perf.push({ coin: coin.symbol, strategy: "MA 9/20", profit: maPerf.profit, accuracy: maPerf.accuracy, trades: maPerf.trades });

    // RSI (14) - treat bullish when RSI < 30 (oversold)
    const rsiPerf = backtestStrategy((c,i)=> signal_RSI14(c,i), ohlc);
    perf.push({ coin: coin.symbol, strategy: "RSI 14", profit: rsiPerf.profit, accuracy: rsiPerf.accuracy, trades: rsiPerf.trades });

    // MACD
    const macdPerf = backtestStrategy((c,i)=> signal_MACD(c,i), ohlc);
    perf.push({ coin: coin.symbol, strategy: "MACD", profit: macdPerf.profit, accuracy: macdPerf.accuracy, trades: macdPerf.trades });

    // Breakout
    const breakoutPerf = backtestStrategy((c,i, highsArg)=> signal_Breakout(highsArg || [], c, i), ohlc);
    perf.push({ coin: coin.symbol, strategy: "Breakout", profit: breakoutPerf.profit, accuracy: breakoutPerf.accuracy, trades: breakoutPerf.trades });

    // RSI OB/OS (explicit)
    const roPerf = backtestStrategy((c,i)=> signal_RSI_OBOS(c,i), ohlc);
    perf.push({ coin: coin.symbol, strategy: "RSI OB/OS", profit: roPerf.profit, accuracy: roPerf.accuracy, trades: roPerf.trades });

    return { coin: coin.symbol, signals, perf, ohlc };
  } catch (e){
    console.warn("analyzeCoin error", coin, e);
    return { coin: coin.symbol, error: true, perf: [] };
  }
}

/* ============================
   UI helpers: badges, sparklines
   ============================ */
function badgeHTML(type){
  const cls = type==="bull" ? "badge bull" : type==="bear" ? "badge bear" : "badge neutral";
  const text = type==="bull" ? "Bullish" : type==="bear" ? "Bearish" : "Neutral";
  return `<span class="${cls}">${text}</span>`;
}

function sparklineSVG(values){
  if (!values || values.length < 2) return '';
  const w=240, h=36, pad=2;
  const min=Math.min(...values), max=Math.max(...values);
  const range = max - min || 1e-6;
  const xs = values.map((_,i)=> pad + (i*(w-2*pad))/(values.length-1));
  const ys = values.map(v => h - pad - ((v-min)*(h-2*pad))/range);
  const path = xs.map((x,i)=> (i? 'L':'M') + x.toFixed(1) + ',' + ys[i].toFixed(1)).join(' ');
  return `<svg class="spark" viewBox="0 0 ${w} ${h}" preserveAspectRatio="none"><path d="${path}" fill="none" stroke="${'#00ffcc'}" stroke-width="2" /></svg>`;
}

/* ============================
   Rendering functions
   ============================ */
async function refreshAll(){
  try{
    $("#refreshNow").disabled = true;
    $("#lastUpdated").textContent = `Refreshing…`;
    // 1) Live prices (simple)
    await renderPrices();

    // 2) Dashboard BTC chart
    await renderBtcChart();

    // 3) News
    await renderNews();

    // 4) Analyze each coin (indicators + backtests) in parallel
    const analyses = await Promise.all(COINS.map(c => analyzeCoin(c)));

    // Build performance table and high-performance banner
    renderPerformanceTable(analyses);

    // Build trading screens area (signals + charts)
    renderTradingScreens(analyses);

    $("#lastUpdated").textContent = `Last updated: ${nowStr()}`;
  } catch(e){
    console.error(e);
    $("#lastUpdated").textContent = `Error: ${e.message}`;
  } finally {
    $("#refreshNow").disabled = false;
  }
}

async function renderPrices(){
  try{
    const ids = COINS.map(c=>c.id).join(',');
    const res = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${ids}&vs_currencies=usd&include_24hr_change=true`);
    const json = await res.json();
    const container = $("#prices");
    container.innerHTML = '';
    COINS.forEach(c => {
      const d = json[c.id];
      if (!d) return;
      const pct = Number(d.usd_24h_change).toFixed(2);
      const p = Number(d.usd).toLocaleString(undefined, {minimumFractionDigits:2, maximumFractionDigits:2});
      const el = document.createElement('div');
      el.className = 'price-card card';
      el.innerHTML = `<div class="price-symbol">${c.symbol}</div><div>$${p}</div><div style="color:${pct>=0? 'lightgreen':'salmon'}">${pct}% (24h)</div>`;
      container.appendChild(el);
    });
  } catch (e){
    console.warn("renderPrices err", e);
    $("#prices").innerHTML = '<div class="card">Failed to load prices</div>';
  }
}

let btcChartInstance = null;
async function renderBtcChart(){
  try{
    const res = await fetch('https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=30');
    const json = await res.json();
    const labels = json.prices.map(p => new Date(p[0]).toLocaleDateString());
    const data = json.prices.map(p => p[1]);
    const ctx = document.getElementById('btcChart').getContext('2d');
    if (btcChartInstance) { btcChartInstance.data.labels = labels; btcChartInstance.data.datasets[0].data = data; btcChartInstance.update(); return; }
    btcChartInstance = new Chart(ctx, {
      type: 'line',
      data: { labels, datasets: [{ label: 'BTC USD', data, borderColor: '#00ffcc', backgroundColor: 'rgba(0,255,204,0.05)' }]},
      options: { responsive:true, plugins:{legend:{display:false}}, scales:{x:{ticks:{color:'#cfd6d9'}}, y:{ticks:{color:'#cfd6d9'}}} }
    });
  } catch(e){
    console.warn("btc chart err", e);
  }
}

async function renderNews(){
  try{
    // Use a free feed proxy (rss2json) to simplify - cryptonews feed used earlier
    const res = await fetch('https://api.rss2json.com/v1/api.json?rss_url=https://cryptonews.com/news/feed');
    const json = await res.json();
    const items = json.items?.slice(0,5) || [];
    $("#news").innerHTML = items.map(it => `<div style="margin-bottom:8px"><a href="${it.link}" target="_blank" rel="noopener noreferrer">${it.title}</a><div style="color:var(--muted);font-size:12px">${it.pubDate}</div></div>`).join('');
  } catch(e){
    console.warn("news err", e);
    $("#news").innerHTML = '<div>Failed to load news.</div>';
  }
}

function renderPerformanceTable(analyses){
  const tbody = $("#perfTable tbody");
  let rows = '';
  let highList = [];
  analyses.forEach(a => {
    if (a.error) return;
    a.perf.forEach(p => {
      const cls = (p.profit > 25 && p.accuracy > 75) ? 'green' : (p.profit < 0 || p.accuracy < 50) ? 'red' : 'yellow';
      rows += `<tr class="${cls}"><td>${p.coin}</td><td>${p.strategy}</td><td>${p.profit}%</td><td>${p.accuracy}%</td></tr>`;
      if (p.profit > 25 && p.accuracy > 75) highList.push(`${p.coin} - ${p.strategy} (${p.profit}%, ${p.accuracy}%, trades:${p.trades})`);
    });
  });
  tbody.innerHTML = rows || '<tr><td colspan="4">No data</td></tr>';
  $("#highBanner").innerHTML = highList.length ? `<strong>High Performance:</strong> ${highList.join(' • ')}` : `<strong>High Performance:</strong> None`;
}

/* Build Trading Screens with signals and TradingView charts */
function renderTradingScreens(analyses){
  const container = $("#screensContainer");
  container.innerHTML = '';
  analyses.forEach(a => {
    const coinInfo = COINS.find(c=>c.symbol === a.coin);
    const section = document.createElement('div');
    section.className = 'coin-block';
    section.innerHTML = `
      <div class="coin-head">
        <div style="font-weight:800">${a.coin} — Trading Screens</div>
        <div style="color:var(--muted)">Trades simulated (hold ${HOLD_DAYS} candles)</div>
      </div>
      <div class="card-grid" id="grid-${a.coin}"></div>
      <div class="chart-box" style="margin-top:12px"><div id="tv-${a.coin}" class="chart"></div></div>
    `;
    container.appendChild(section);

    // If error, show note
    const grid = section.querySelector(`#grid-${a.coin}`);
    if (a.error) {
      grid.innerHTML = `<div class="screen-card">Error fetching data.</div>`;
      return;
    }

    // Signals (latest)
    const signals = a.signals;
    // prepare sparkline from last closes
    const spark = sparklineSVG(a.ohlc.closes.slice(-40));

    const cards = [
      {title: 'MA 9/20 crossover', type: signals.ma, note: signals.ma === 'bull' ? 'MA9 > MA20' : 'MA9 ≤ MA20'},
      {title: 'RSI (14)', type: signals.rsi, note: signals.rsi === 'bull' ? 'RSI < 30 (oversold)' : signals.rsi === 'bear' ? 'RSI > 70' : 'Neutral'},
      {title: 'MACD above signal', type: signals.macd, note: signals.macd==='bull'?'MACD > Signal':'MACD ≤ Signal'},
      {title: 'Breakout check', type: signals.breakout, note: signals.breakout==='bull'?'Price > prev7 high':'No breakout'},
      {title: 'RSI OB/OS', type: signals.rsi_obs, note: signals.rsi_obs==='bull'?'Oversold':'Overbought/Neutral'}
    ];

    grid.innerHTML = cards.map(c => {
      return `<div class="screen-card" data-sigtype="${c.type}">
                <div style="display:flex;justify-content:space-between;align-items:center">
                  <div style="font-weight:700">${c.title}</div>
                  ${badgeHTML(c.type)}
                </div>
                <div style="color:var(--muted);margin-top:6px">${c.note}</div>
                ${spark}
              </div>`;
    }).join('');

    // Create TradingView chart (only once) - remove existing innerHTML to avoid duplicates
    const tvId = 'tv-' + a.coin;
    ensureTradingView(a.coin, coinInfo.tv, tvId);
  });
  applyFilter(); // apply chosen filter after render
}

/* TradingView helpers - reuse widgets by clearing container and re-creating */
const createdTV = new Set();
function ensureTradingView(symbol, tvSymbol, containerId){
  // containerId is like 'tv-BTC' — the div; we will instantiate tradingview widget there
  const el = document.getElementById(containerId);
  if (!el) return;
  // Clear any previous content to avoid duplicates
  el.innerHTML = '';
  // Create widget
  try{
    new TradingView.widget({
      container_id: containerId,
      autosize: true,
      symbol: tvSymbol,
      interval: "30",
      timezone: "Etc/UTC",
      theme: "dark",
      style: "1",
      locale: "en",
      studies: ["MACD@tv-basicstudies","RSI@tv-basicstudies"],
      allow_symbol_change: false
    });
    createdTV.add(containerId);
  } catch(e){
    console.warn("TradingView init failed", e);
  }
}

/* Filter apply */
function applyFilter(){
  const val = $("#filterSelect").value;
  $$(".screen-card").forEach(card => {
    const t = card.getAttribute('data-sigtype');
    card.style.display = (val === 'all' || val === t) ? '' : 'none';
  });
}

/* ============================
   Events and init
   ============================ */
$("#btnDash").addEventListener('click', ()=>{ $("#dashboardView").style.display='block'; $("#screensView").style.display='none'; $("#btnDash").classList.add('active'); $("#btnScreens").classList.remove('active'); });
$("#btnScreens").addEventListener('click', ()=>{ $("#dashboardView").style.display='none'; $("#screensView").style.display='block'; $("#btnScreens").classList.add('active'); $("#btnDash").classList.remove('active'); });
$("#refreshNow").addEventListener('click', refreshAll);
$("#filterSelect").addEventListener('change', applyFilter);

// Initial load
refreshAll();
setInterval(refreshAll, REFRESH_MS);

</script>
</body>
</html>
